#!/bin/bash
set -euo pipefail

echo "Building Rust core..."

# Ensure rustup toolchain is available in Xcode build environment
export PATH="$HOME/.cargo/bin:$PATH"

# Go to repo root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT/core/rust"

# Keep Rust min deployment target aligned with Xcode (macOS 11.0 baseline).
export MACOSX_DEPLOYMENT_TARGET="${MACOSX_DEPLOYMENT_TARGET:-11.0}"

MIN_MACOS_LINK_ARG="-C link-arg=-mmacosx-version-min=${MACOSX_DEPLOYMENT_TARGET}"
case " ${RUSTFLAGS:-} " in
    *" ${MIN_MACOS_LINK_ARG} "*) ;;
    *)
        export RUSTFLAGS="${RUSTFLAGS:+$RUSTFLAGS }${MIN_MACOS_LINK_ARG}"
        ;;
esac

# Isolate Xcode-driven cargo output so stale artifacts built with higher deployment
# targets do not leak into app links.
TARGET_SUFFIX="${MACOSX_DEPLOYMENT_TARGET//./_}"
export CARGO_TARGET_DIR="$REPO_ROOT/core/rust/target/xcode-macos${TARGET_SUFFIX}"

# Determine build profile
if [[ "${CONFIGURATION:-Debug}" == Release* ]]; then
    PROFILE="release"
    CARGO_FLAGS="--release"
else
    PROFILE="debug"
    CARGO_FLAGS=""
fi

# Map Xcode architecture names to Rust target triples.
map_arch_to_target() {
    case "$1" in
        arm64|arm64e)
            echo "aarch64-apple-darwin"
            ;;
        x86_64)
            echo "x86_64-apple-darwin"
            ;;
        *)
            return 1
            ;;
    esac
}

# Xcode provides ARCHS (e.g. "arm64 x86_64") when building for "Any Mac".
REQUESTED_ARCHS="${ARCHS:-$(uname -m)}"
IFS=' ' read -r -a XCODE_ARCHS <<< "$REQUESTED_ARCHS"

RUST_TARGETS=()
for arch in "${XCODE_ARCHS[@]}"; do
    target=$(map_arch_to_target "$arch" || true)
    if [ -n "${target:-}" ]; then
        already_present=0
        for existing in "${RUST_TARGETS[@]:-}"; do
            if [ "$existing" = "$target" ]; then
                already_present=1
                break
            fi
        done
        if [ "$already_present" -eq 0 ]; then
            RUST_TARGETS+=("$target")
        fi
    fi
done

if [ "${#RUST_TARGETS[@]}" -eq 0 ]; then
    host_target=$(map_arch_to_target "$(uname -m)" || true)
    if [ -z "${host_target:-}" ]; then
        echo "Unsupported host architecture: $(uname -m)" >&2
        exit 1
    fi
    RUST_TARGETS+=("$host_target")
fi

echo "Requested Xcode ARCHS: $REQUESTED_ARCHS"
echo "Rust targets: ${RUST_TARGETS[*]}"

LIB_INPUTS=()
CARGO_OUTPUT_DIR="${CARGO_TARGET_DIR:-target}"
installed_targets=""
if command -v rustup >/dev/null 2>&1; then
    installed_targets=$(rustup target list --installed || true)
fi

for target in "${RUST_TARGETS[@]}"; do
    if [ -n "$installed_targets" ] && ! printf '%s\n' "$installed_targets" | grep -qx "$target"; then
        if [ "${HELM_AUTO_INSTALL_RUST_TARGETS:-1}" = "1" ] && command -v rustup >/dev/null 2>&1; then
            echo "Installing missing Rust target: $target"
            rustup target add "$target" || true
            installed_targets=$(rustup target list --installed || true)
        fi
    fi

    if [ -n "$installed_targets" ] && ! printf '%s\n' "$installed_targets" | grep -qx "$target"; then
        if [ "$CONFIGURATION" = "Release" ]; then
            echo "Required Rust target is missing for Release build: $target" >&2
            exit 1
        fi
        echo "Skipping unavailable Rust target in non-Release build: $target"
        continue
    fi

    echo "Building helm-ffi for $target..."
    cargo build -p helm-ffi $CARGO_FLAGS --target "$target"
    LIB_INPUTS+=("$CARGO_OUTPUT_DIR/$target/$PROFILE/libhelm_ffi.a")
done

if [ "${#LIB_INPUTS[@]}" -eq 0 ]; then
    echo "No Rust targets were built. Ensure rustup targets are installed." >&2
    exit 1
fi

# Copy artifacts to a build directory inside apps/macos-ui
# ensuring Xcode can find them
DEST_DIR="$REPO_ROOT/apps/macos-ui/Generated"
mkdir -p "$DEST_DIR"

"$REPO_ROOT/apps/macos-ui/scripts/render_channel_xcconfig.sh" "$DEST_DIR/HelmChannel.xcconfig"

if [ "${#LIB_INPUTS[@]}" -eq 1 ]; then
    cp "${LIB_INPUTS[0]}" "$DEST_DIR/libhelm_ffi.a"
else
    echo "Creating universal static library..."
    lipo -create "${LIB_INPUTS[@]}" -output "$DEST_DIR/libhelm_ffi.a"
fi
cp "crates/helm-ffi/include/helm.h" "$DEST_DIR/"

# Extract version from workspace Cargo.toml and generate Swift constant
VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
cat > "$DEST_DIR/HelmVersion.swift" <<SWIFT
// Auto-generated by build_rust.sh — do not edit
let helmVersion = "$VERSION"
SWIFT

# Generate xcconfig for Xcode bundle version synchronization.
# Keep prerelease suffixes in MARKETING_VERSION for direct-channel RC visibility
# in Sparkle "up to date" UI. App Store channel continues to receive X.Y.Z only.
if [[ "${HELM_DISTRIBUTION_CHANNEL:-developer_id}" == "app_store" ]]; then
    MARKETING_VERSION=$(echo "$VERSION" | sed 's/-.*//')
else
    MARKETING_VERSION="$VERSION"
fi

# Derive a monotonic numeric build number for Sparkle comparisons.
# Format:
#   base = major * 1_000_000 + minor * 1_000 + patch
#   stable build suffix = 900
#   prerelease suffixes:
#     alpha.N => 100 + N
#     beta.N  => 300 + N
#     rc.N    => 600 + N
# This guarantees:
#   alpha < beta < rc < stable for the same X.Y.Z base.
if [[ "$VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(-([A-Za-z]+)\.([0-9]+))?$ ]]; then
    MAJOR="${BASH_REMATCH[1]}"
    MINOR="${BASH_REMATCH[2]}"
    PATCH="${BASH_REMATCH[3]}"
    PRE_LABEL="${BASH_REMATCH[5]:-}"
    PRE_NUMBER="${BASH_REMATCH[6]:-0}"
    PRE_LABEL_LOWER=$(printf '%s' "$PRE_LABEL" | tr '[:upper:]' '[:lower:]')

    BASE=$((MAJOR * 1000000 + MINOR * 1000 + PATCH))

    if [ -z "$PRE_LABEL" ]; then
        SUFFIX=900
    else
        case "$PRE_LABEL_LOWER" in
            alpha)
                STAGE=100
                ;;
            beta)
                STAGE=300
                ;;
            rc)
                STAGE=600
                ;;
            *)
                STAGE=50
                ;;
        esac
        if [ "$PRE_NUMBER" -gt 99 ]; then
            PRE_NUMBER=99
        fi
        SUFFIX=$((STAGE + PRE_NUMBER))
    fi

    BUILD_NUMBER=$((BASE * 1000 + SUFFIX))
else
    echo "Warning: unable to parse semantic version '$VERSION'; using build number 1" >&2
    BUILD_NUMBER=1
fi

cat > "$DEST_DIR/HelmVersion.xcconfig" <<XCCONFIG
// Auto-generated by build_rust.sh — do not edit
MARKETING_VERSION = $MARKETING_VERSION
CURRENT_PROJECT_VERSION = $BUILD_NUMBER
XCCONFIG

echo "Rust build complete (v$VERSION). Artifacts in $DEST_DIR"
