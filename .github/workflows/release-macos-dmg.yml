name: Release macOS DMG

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Git tag to build and upload (e.g. v0.13.0-beta.2)"
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-dmg-${{ github.event.release.tag_name || github.event.inputs.tag }}
  cancel-in-progress: true

jobs:
  build-and-upload-dmg:
    runs-on: macos-14
    env:
      APP_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      SIGNING_CERT_BASE64: ${{ secrets.MACOS_DEVELOPER_ID_APP_CERT_BASE64 }}
      SIGNING_CERT_PASSWORD: ${{ secrets.MACOS_DEVELOPER_ID_APP_CERT_PASSWORD }}
      KEYCHAIN_PASSWORD: ${{ secrets.MACOS_KEYCHAIN_PASSWORD }}
      HELM_SPARKLE_FEED_URL: ${{ secrets.HELM_SPARKLE_FEED_URL }}
      HELM_SPARKLE_PUBLIC_ED_KEY: ${{ secrets.HELM_SPARKLE_PUBLIC_ED_KEY }}
      HELM_SPARKLE_PRIVATE_ED_KEY: ${{ secrets.HELM_SPARKLE_PRIVATE_ED_KEY }}
      TAG_NAME: ${{ github.event.release.tag_name || github.event.inputs.tag }}

    steps:
      - name: Validate required secrets
        run: |
          set -euo pipefail
          required=(APP_TEAM_ID SIGNING_CERT_BASE64 SIGNING_CERT_PASSWORD HELM_SPARKLE_FEED_URL HELM_SPARKLE_PUBLIC_ED_KEY HELM_SPARKLE_PRIVATE_ED_KEY)
          for key in "${required[@]}"; do
            if [ -z "${!key}" ]; then
              echo "::error::Missing required secret: $key"
              exit 1
            fi
          done

          python3 - <<'PY'
          import os
          import socket
          import sys
          from urllib.parse import urlparse

          feed_url = os.environ["HELM_SPARKLE_FEED_URL"]
          parsed = urlparse(feed_url)
          if parsed.scheme.lower() != "https" or not parsed.hostname:
              print(f"::error::HELM_SPARKLE_FEED_URL must be an absolute https URL. Got: {feed_url}")
              sys.exit(1)

          host = parsed.hostname
          try:
              socket.getaddrinfo(host, 443)
          except OSError as exc:
              print(f"::error::HELM_SPARKLE_FEED_URL host is not resolvable in CI DNS: host={host} error={exc}")
              sys.exit(1)

          print(f"HELM_SPARKLE_FEED_URL host resolved: {host}")
          PY

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ env.TAG_NAME }}

      - name: Install Rust toolchain (universal targets)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Configure temporary keychain and import Developer ID certificate
        env:
          RUNNER_KEYCHAIN: build-signing.keychain-db
        run: |
          set -euo pipefail
          CERT_P12="$RUNNER_TEMP/developer-id-app.p12"
          if ! echo "$SIGNING_CERT_BASE64" | base64 --decode > "$CERT_P12" 2>/dev/null; then
            echo "$SIGNING_CERT_BASE64" | base64 -D > "$CERT_P12"
          fi

          KEYCHAIN_PWD="${KEYCHAIN_PASSWORD:-$(openssl rand -base64 24)}"
          security create-keychain -p "$KEYCHAIN_PWD" "$RUNNER_KEYCHAIN"
          security set-keychain-settings -lut 21600 "$RUNNER_KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$RUNNER_KEYCHAIN"
          security list-keychains -d user -s "$RUNNER_KEYCHAIN" login.keychain-db
          security import "$CERT_P12" -k "$RUNNER_KEYCHAIN" -P "$SIGNING_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$RUNNER_KEYCHAIN"

      - name: Run Rust tests before release build
        run: |
          set -euo pipefail
          cd core/rust
          cargo test --workspace

      - name: Run Swift tests before release build
        run: |
          set -euo pipefail
          HELM_CHANNEL_PROFILE=developer_id \
          xcodebuild \
            -project apps/macos-ui/Helm.xcodeproj \
            -scheme Helm \
            -destination "platform=macOS" \
            -configuration Debug \
            CODE_SIGN_IDENTITY=- \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            test

      - name: Build signed universal app
        run: |
          set -euo pipefail
          HELM_CHANNEL_PROFILE=developer_id \
          HELM_CHANNEL_OVERRIDE_SPARKLE_ENABLED=YES \
          HELM_CHANNEL_OVERRIDE_SPARKLE_FEED_URL="$HELM_SPARKLE_FEED_URL" \
          HELM_CHANNEL_OVERRIDE_SPARKLE_PUBLIC_ED_KEY="$HELM_SPARKLE_PUBLIC_ED_KEY" \
          apps/macos-ui/scripts/render_channel_xcconfig.sh "$PWD/apps/macos-ui/Generated/HelmChannel.xcconfig"
          echo "=== Generated HelmChannel.xcconfig (release override) ==="
          cat "$PWD/apps/macos-ui/Generated/HelmChannel.xcconfig"

          HELM_CHANNEL_PROFILE=developer_id \
          HELM_CHANNEL_OVERRIDE_SPARKLE_ENABLED=YES \
          HELM_CHANNEL_OVERRIDE_SPARKLE_FEED_URL="$HELM_SPARKLE_FEED_URL" \
          HELM_CHANNEL_OVERRIDE_SPARKLE_PUBLIC_ED_KEY="$HELM_SPARKLE_PUBLIC_ED_KEY" \
          xcodebuild \
            -project apps/macos-ui/Helm.xcodeproj \
            -scheme Helm \
            -configuration Release \
            -destination "generic/platform=macOS" \
            -derivedDataPath "$PWD/build/DerivedData" \
            ARCHS="arm64 x86_64" \
            ONLY_ACTIVE_ARCH=NO \
            HELM_DISTRIBUTION_CHANNEL=developer_id \
            HELM_SPARKLE_ENABLED=YES \
            HELM_SPARKLE_ALLOW_DOWNGRADES=NO \
            HELM_SPARKLE_FEED_URL="$HELM_SPARKLE_FEED_URL" \
            HELM_SPARKLE_PUBLIC_ED_KEY="$HELM_SPARKLE_PUBLIC_ED_KEY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$APP_TEAM_ID" \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            ENABLE_HARDENED_RUNTIME=YES \
            OTHER_CODE_SIGN_FLAGS="--timestamp" \
            build

      - name: Re-sign Sparkle nested binaries for notarization
        run: |
          set -euo pipefail

          APP_PATH="$PWD/build/DerivedData/Build/Products/Release/Helm.app"
          SPARKLE_VERSION_DIR="$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B"
          SIGN_IDENTITY="Developer ID Application"

          test -d "$APP_PATH"
          test -d "$SPARKLE_VERSION_DIR"

          codesign --force --timestamp --sign "$SIGN_IDENTITY" "$SPARKLE_VERSION_DIR/Autoupdate"
          codesign --force --deep --timestamp --options runtime --sign "$SIGN_IDENTITY" "$SPARKLE_VERSION_DIR/Updater.app"
          codesign --force --deep --timestamp --options runtime --sign "$SIGN_IDENTITY" "$SPARKLE_VERSION_DIR/XPCServices/Downloader.xpc"
          codesign --force --deep --timestamp --options runtime --sign "$SIGN_IDENTITY" "$SPARKLE_VERSION_DIR/XPCServices/Installer.xpc"
          codesign --force --deep --timestamp --options runtime --sign "$SIGN_IDENTITY" "$APP_PATH/Contents/Frameworks/Sparkle.framework"
          codesign --force --deep --timestamp --options runtime --sign "$SIGN_IDENTITY" --preserve-metadata=entitlements,requirements,flags "$APP_PATH"

          echo "=== Sparkle signing check ==="
          codesign -dv --verbose=4 "$SPARKLE_VERSION_DIR/Autoupdate" 2>&1 | grep -E "Authority=Developer ID Application|Timestamp="
          codesign -dv --verbose=4 "$SPARKLE_VERSION_DIR/Updater.app/Contents/MacOS/Updater" 2>&1 | grep -E "Authority=Developer ID Application|Timestamp="

      - name: Verify signature, architecture, and notarization prerequisites
        run: |
          set -euo pipefail
          APP_PATH="$PWD/build/DerivedData/Build/Products/Release/Helm.app"
          HELM_BIN="$APP_PATH/Contents/MacOS/Helm"
          XPC_BIN="$APP_PATH/Contents/XPCServices/HelmService.xpc/Contents/MacOS/HelmService"
          APP_INFO_PLIST="$APP_PATH/Contents/Info.plist"
          SPARKLE_FRAMEWORK="$APP_PATH/Contents/Frameworks/Sparkle.framework"

          test -d "$APP_PATH"

          echo "=== Update channel metadata ==="
          CHANNEL=$(/usr/libexec/PlistBuddy -c "Print :HelmDistributionChannel" "$APP_INFO_PLIST")
          SPARKLE_ENABLED=$(/usr/libexec/PlistBuddy -c "Print :HelmSparkleEnabled" "$APP_INFO_PLIST")
          SPARKLE_ALLOWS_DOWNGRADES=$(/usr/libexec/PlistBuddy -c "Print :SUAllowsDowngrades" "$APP_INFO_PLIST")
          SPARKLE_FEED_URL=$(/usr/libexec/PlistBuddy -c "Print :SUFeedURL" "$APP_INFO_PLIST")
          SPARKLE_PUBLIC_ED_KEY=$(/usr/libexec/PlistBuddy -c "Print :SUPublicEDKey" "$APP_INFO_PLIST")

          echo "channel=$CHANNEL"
          echo "sparkle_enabled=$SPARKLE_ENABLED"
          echo "sparkle_allows_downgrades=$SPARKLE_ALLOWS_DOWNGRADES"
          echo "sparkle_feed_url=$SPARKLE_FEED_URL"
          echo "sparkle_public_ed_key_length=${#SPARKLE_PUBLIC_ED_KEY}"

          if [ "$CHANNEL" != "developer_id" ]; then
            echo "::error::Unexpected HelmDistributionChannel in release artifact: $CHANNEL"
            exit 1
          fi

          SPARKLE_ENABLED_NORMALIZED="$(echo "$SPARKLE_ENABLED" | tr '[:upper:]' '[:lower:]')"
          if [ "$SPARKLE_ENABLED_NORMALIZED" != "yes" ] && [ "$SPARKLE_ENABLED_NORMALIZED" != "true" ] && [ "$SPARKLE_ENABLED_NORMALIZED" != "1" ]; then
            echo "::error::HelmSparkleEnabled is not true in release artifact: $SPARKLE_ENABLED"
            exit 1
          fi

          SPARKLE_ALLOWS_DOWNGRADES_NORMALIZED="$(echo "$SPARKLE_ALLOWS_DOWNGRADES" | tr '[:upper:]' '[:lower:]')"
          if [ "$SPARKLE_ALLOWS_DOWNGRADES_NORMALIZED" != "no" ] && [ "$SPARKLE_ALLOWS_DOWNGRADES_NORMALIZED" != "false" ] && [ "$SPARKLE_ALLOWS_DOWNGRADES_NORMALIZED" != "0" ]; then
            echo "::error::SUAllowsDowngrades must be false in release artifact: $SPARKLE_ALLOWS_DOWNGRADES"
            exit 1
          fi

          if [[ "$SPARKLE_FEED_URL" != https://* ]]; then
            echo "::error::SUFeedURL must be https:// in release artifact."
            exit 1
          fi

          if [ -z "$SPARKLE_PUBLIC_ED_KEY" ]; then
            echo "::error::SUPublicEDKey is empty in release artifact."
            exit 1
          fi

          test -d "$SPARKLE_FRAMEWORK"
          if ! otool -L "$HELM_BIN" | grep -q "Sparkle.framework"; then
            echo "::error::Sparkle framework is not linked into Helm binary."
            exit 1
          fi

          echo "=== Architectures ==="
          lipo -archs "$HELM_BIN"

          echo "=== Codesign verify (deep, strict) ==="
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

          echo "=== Helm binary: entitlements ==="
          codesign -d --entitlements :- "$HELM_BIN" 2>/dev/null || echo "(no entitlements)"

          echo "=== Helm binary: codesign details ==="
          codesign -dv --verbose=4 "$HELM_BIN" 2>&1

          echo "=== HelmService binary: entitlements ==="
          codesign -d --entitlements :- "$XPC_BIN" 2>/dev/null || echo "(no entitlements)"

          echo "=== HelmService binary: codesign details ==="
          codesign -dv --verbose=4 "$XPC_BIN" 2>&1

          echo "=== Notarization pre-check: hardened runtime flags ==="
          # CodeDirectory flags should include 'runtime' for hardened runtime
          if codesign -dv --verbose=4 "$HELM_BIN" 2>&1 | grep -q "flags=0x10000(runtime)"; then
            echo "Helm: hardened runtime flag present ✓"
          else
            echo "::warning::Helm: hardened runtime flag NOT detected in codesign output"
          fi
          if codesign -dv --verbose=4 "$XPC_BIN" 2>&1 | grep -q "flags=0x10000(runtime)"; then
            echo "HelmService: hardened runtime flag present ✓"
          else
            echo "::warning::HelmService: hardened runtime flag NOT detected in codesign output"
          fi

          echo "=== Notarization pre-check: get-task-allow must be absent ==="
          if codesign -d --entitlements :- "$HELM_BIN" 2>/dev/null | grep -q "get-task-allow"; then
            echo "::error::Helm: get-task-allow entitlement present — notarization will fail"
            exit 1
          else
            echo "Helm: no get-task-allow ✓"
          fi
          if codesign -d --entitlements :- "$XPC_BIN" 2>/dev/null | grep -q "get-task-allow"; then
            echo "::error::HelmService: get-task-allow entitlement present — notarization will fail"
            exit 1
          else
            echo "HelmService: no get-task-allow ✓"
          fi

      - name: Create polished drag-to-Applications DMG
        run: |
          set -euo pipefail

          APP_PATH="$PWD/build/DerivedData/Build/Products/Release/Helm.app"
          STAGING_DIR="$PWD/build/dmg-staging"
          OUTPUT_DIR="$PWD/build/release-assets"
          DMG_TMP="$PWD/build/tmp.dmg"

          VERSIONED_DMG="$OUTPUT_DIR/Helm-${TAG_NAME}-macos-universal.dmg"
          LATEST_DMG="$OUTPUT_DIR/Helm.dmg"
          VOLUME_NAME="Helm"
          MOUNT_PATH="/Volumes/$VOLUME_NAME"

          # Sanity checks
          test -d "$APP_PATH"
          test -f "$PWD/assets/dmg/background.png"

          rm -rf "$STAGING_DIR" "$OUTPUT_DIR" "$DMG_TMP"
          mkdir -p "$STAGING_DIR" "$OUTPUT_DIR"

          cp -R "$APP_PATH" "$STAGING_DIR/"
          ln -s /Applications "$STAGING_DIR/Applications"

          # Create writable DMG so we can set Finder metadata
          hdiutil create \
            -volname "$VOLUME_NAME" \
            -srcfolder "$STAGING_DIR" \
            -ov \
            -format UDRW \
            "$DMG_TMP"

          # Mount (read/write), no Finder auto-open
          DEVICE="$(hdiutil attach -readwrite -noverify -noautoopen "$DMG_TMP" | awk '/^\/dev/ {print $1; exit}')"

          # Ensure detach happens even if AppleScript fails
          cleanup() {
            if mount | rg -q "$MOUNT_PATH"; then
              hdiutil detach "$DEVICE" || hdiutil detach -force "$DEVICE" || true
            fi
          }
          trap cleanup EXIT

          # Give the system a moment to mount
          sleep 3

          # Background image (600x400)
          mkdir -p "$MOUNT_PATH/.background"
          cp "$PWD/assets/dmg/background.png" "$MOUNT_PATH/.background/background.png"

          # Configure Finder window:
          # bounds {x1,y1,x2,y2} => width=600 height=400 (700-100, 500-100)
          osascript <<EOF
          tell application "Finder"
            tell disk "$VOLUME_NAME"
              open
              set current view of container window to icon view
              set toolbar visible of container window to false
              set statusbar visible of container window to false
              set bounds of container window to {100, 100, 700, 500}

              set viewOptions to the icon view options of container window
              set arrangement of viewOptions to not arranged
              set icon size of viewOptions to 128
              set background picture of viewOptions to file ".background:background.png"

              set position of item "Helm.app" of container window to {150, 210}
              set position of item "Applications" of container window to {450, 210}

              close
              open
              update without registering applications
              delay 3
            end tell
          end tell
          EOF

          sync
          sleep 1

          # Detach (trap will also attempt)
          hdiutil detach "$DEVICE"

          # Convert to compressed readonly DMG
          hdiutil convert "$DMG_TMP" -format UDZO -o "$VERSIONED_DMG"
          cp "$VERSIONED_DMG" "$LATEST_DMG"

      - name: Verify packaged DMG layout and updater invariants
        run: |
          set -euo pipefail
          apps/macos-ui/scripts/verify_release_dmg.sh "$PWD/build/release-assets/Helm-${TAG_NAME}-macos-universal.dmg"
          apps/macos-ui/scripts/verify_release_dmg.sh "$PWD/build/release-assets/Helm.dmg"

      - name: Notarize DMG (App Store Connect API key)
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: |
          set -euo pipefail

          KEY_PATH="$RUNNER_TEMP/AuthKey_${ASC_KEY_ID}.p8"
          if ! echo "$ASC_PRIVATE_KEY_BASE64" | base64 --decode > "$KEY_PATH" 2>/dev/null; then
            echo "$ASC_PRIVATE_KEY_BASE64" | base64 -D > "$KEY_PATH"
          fi

          DMG_PATH="$PWD/build/release-assets/Helm-${TAG_NAME}-macos-universal.dmg"

          # Submit and capture JSON output so we can always fetch the log
          OUT_JSON="$RUNNER_TEMP/notarytool-submit.json"
          xcrun notarytool submit "$DMG_PATH" \
            --key "$KEY_PATH" \
            --key-id "$ASC_KEY_ID" \
            --issuer "$ASC_ISSUER_ID" \
            --wait --output-format json | tee "$OUT_JSON"

          SUB_ID="$(python3 -c 'import json;print(json.load(open("'"$OUT_JSON"'"))["id"])')"
          STATUS="$(python3 -c 'import json;print(json.load(open("'"$OUT_JSON"'"))["status"])')"

          # If invalid, fetch and print the full log, then fail (don’t try stapling)
          if [ "$STATUS" != "Accepted" ]; then
            echo "::error::Notarization failed with status: $STATUS (submission id: $SUB_ID)"
            xcrun notarytool log "$SUB_ID" \
              --key "$KEY_PATH" \
              --key-id "$ASC_KEY_ID" \
              --issuer "$ASC_ISSUER_ID"
            exit 1
          fi

          # Only staple if accepted
          xcrun stapler staple "$DMG_PATH"
          xcrun stapler staple "$PWD/build/release-assets/Helm.dmg"

      - name: Generate Sparkle appcast from final DMG
        run: |
          set -euo pipefail
          APP_PATH="$PWD/build/DerivedData/Build/Products/Release/Helm.app"
          DMG_PATH="$PWD/build/release-assets/Helm-${TAG_NAME}-macos-universal.dmg"
          APPCAST_PATH="$PWD/build/release-assets/appcast.xml"
          RELEASE_NOTES_PATH="$PWD/build/release-assets/release-notes/${TAG_NAME}.html"
          DOWNLOAD_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${TAG_NAME}/Helm-${TAG_NAME}-macos-universal.dmg"
          RELEASE_NOTES_URL="$(
            python3 - <<'PY'
          import os
          from urllib.parse import urlparse, urlunparse

          feed_url = os.environ["HELM_SPARKLE_FEED_URL"]
          tag_name = os.environ["TAG_NAME"]
          parsed = urlparse(feed_url)

          base_path = parsed.path
          if base_path.endswith("/appcast.xml"):
            base_path = base_path[: -len("/appcast.xml")]
          else:
            base_path = base_path.rstrip("/")

          if not base_path:
            notes_path = f"/release-notes/{tag_name}.html"
          else:
            notes_path = f"{base_path}/release-notes/{tag_name}.html"

          print(urlunparse((parsed.scheme, parsed.netloc, notes_path, "", "", "")))
          PY
          )"
          GITHUB_RELEASE_URL="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG_NAME}"
          DISPLAY_VERSION="${TAG_NAME#v}"

          apps/macos-ui/scripts/generate_release_notes_html.py \
            --changelog-path "$PWD/CHANGELOG.md" \
            --tag "$TAG_NAME" \
            --output-path "$RELEASE_NOTES_PATH" \
            --canonical-url "$RELEASE_NOTES_URL" \
            --fallback-release-url "$GITHUB_RELEASE_URL"

          apps/macos-ui/scripts/generate_sparkle_appcast.sh \
            --app-path "$APP_PATH" \
            --dmg-path "$DMG_PATH" \
            --output-path "$APPCAST_PATH" \
            --download-url "$DOWNLOAD_URL" \
            --appcast-url "$HELM_SPARKLE_FEED_URL" \
            --display-version "$DISPLAY_VERSION" \
            --release-notes-url "$RELEASE_NOTES_URL"

      - name: Enforce Sparkle appcast policy (full installer only)
        run: |
          set -euo pipefail
          apps/macos-ui/scripts/verify_sparkle_appcast_policy.sh "$PWD/build/release-assets/appcast.xml"

      - name: Upload build artifacts to workflow run
        uses: actions/upload-artifact@v4
        with:
          name: helm-macos-dmg-${{ env.TAG_NAME }}
          path: |
            build/release-assets/*.dmg
            build/release-assets/appcast.xml
            build/release-assets/release-notes/*.html

      - name: Upload DMGs to GitHub release
        if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh release upload "$TAG_NAME" \
            "build/release-assets/Helm-${TAG_NAME}-macos-universal.dmg#Helm-${TAG_NAME}-macos-universal.dmg" \
            "build/release-assets/Helm.dmg#Helm.dmg" \
            "build/release-assets/appcast.xml#appcast.xml" \
            "build/release-assets/release-notes/${TAG_NAME}.html#release-notes-${TAG_NAME}.html" \
            --clobber

      - name: Publish appcast and release notes to website source
        if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          APPCAST_PATH="$PWD/build/release-assets/appcast.xml"
          RELEASE_NOTES_PATH="$PWD/build/release-assets/release-notes/${TAG_NAME}.html"
          FEED_PATH="web/public/updates/appcast.xml"
          RELEASE_NOTES_FEED_PATH="web/public/updates/release-notes/${TAG_NAME}.html"
          PUBLISH_DIR="$RUNNER_TEMP/appcast-publish"
          PUBLISH_BRANCH="chore/publish-updates-${TAG_NAME}"

          git clone --depth 1 --branch main "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" "$PUBLISH_DIR"
          mkdir -p "$PUBLISH_DIR/$(dirname "$FEED_PATH")"
          mkdir -p "$PUBLISH_DIR/$(dirname "$RELEASE_NOTES_FEED_PATH")"
          cp "$APPCAST_PATH" "$PUBLISH_DIR/$FEED_PATH"
          cp "$RELEASE_NOTES_PATH" "$PUBLISH_DIR/$RELEASE_NOTES_FEED_PATH"

          cd "$PUBLISH_DIR"
          if [ -z "$(git status --porcelain -- "$FEED_PATH" "$RELEASE_NOTES_FEED_PATH")" ]; then
            echo "Appcast and release notes are already current on main."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "$FEED_PATH" "$RELEASE_NOTES_FEED_PATH"
          git commit -m "chore(release): publish Sparkle appcast + release notes for ${TAG_NAME}"

          if git push origin HEAD:main; then
            echo "Published appcast directly to main."
            exit 0
          fi

          echo "Direct push to main was rejected, creating PR fallback."
          git checkout -b "$PUBLISH_BRANCH"
          git push -u origin "$PUBLISH_BRANCH" --force-with-lease

          EXISTING_PR="$(gh pr list --repo "$GITHUB_REPOSITORY" --base main --head "$PUBLISH_BRANCH" --state open --json number --jq '.[0].number' || true)"
          if [ -n "$EXISTING_PR" ]; then
            echo "PR already exists for $PUBLISH_BRANCH (#$EXISTING_PR)."
            exit 0
          fi

          PR_URL="$(gh pr create \
            --repo "$GITHUB_REPOSITORY" \
            --base main \
            --head "$PUBLISH_BRANCH" \
            --title "chore(release): publish Sparkle appcast + release notes for ${TAG_NAME}" \
            --body "$(cat <<EOF
          This PR was auto-generated by \`release-macos-dmg.yml\`.

          It publishes Sparkle update metadata for \`${TAG_NAME}\` to:
          - \`${FEED_PATH}\`
          - \`${RELEASE_NOTES_FEED_PATH}\`

          Merge this PR to update:
          - \`https://helmapp.dev/updates/appcast.xml\`
          - \`https://helmapp.dev/updates/release-notes/${TAG_NAME}.html\`
          EOF
          )" 2>&1)" || {
            echo "::error::Unable to auto-create fallback PR via GitHub Actions token."
            echo "::error::Likely cause: repository setting disallows Actions PR creation."
            echo "::error::Fallback branch was pushed: ${PUBLISH_BRANCH}"
            echo "::error::Open manual PR: https://github.com/${GITHUB_REPOSITORY}/compare/main...${PUBLISH_BRANCH}?expand=1"
            echo "::error::gh output: ${PR_URL}"
            exit 1
          }

          echo "Created fallback PR: ${PR_URL}"

      - name: Verify appcast on main matches release tag
        if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          FEED_PATH="web/public/updates/appcast.xml"
          VERIFY_DIR="$RUNNER_TEMP/appcast-verify-main"
          EXPECTED_VERSION="${TAG_NAME#v}"

          git clone --depth 1 --branch main "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" "$VERIFY_DIR"
          MAIN_FEED="$VERIFY_DIR/$FEED_PATH"

          if [ ! -f "$MAIN_FEED" ]; then
            echo "::error::Expected appcast file not found on main: ${FEED_PATH}"
            exit 1
          fi

          ACTUAL_VERSION="$(
            MAIN_FEED="$MAIN_FEED" python3 - <<'PY'
            import os
            import xml.etree.ElementTree as ET

            sparkle_ns = "http://www.andymatuschak.org/xml-namespaces/sparkle"
            feed_path = os.environ["MAIN_FEED"]

            root = ET.parse(feed_path).getroot()
            item = root.find("./channel/item")
            if item is None:
                print("")
                raise SystemExit(0)

            enclosure = item.find("enclosure")
            version = ""
            if enclosure is not None:
                version = enclosure.attrib.get(f"{{{sparkle_ns}}}shortVersionString", "").strip()

            if not version:
                title = (item.findtext("title") or "").strip()
                if title.lower().startswith("helm "):
                    version = title[5:].strip()

            print(version)
            PY
          )"

          if [ -z "$ACTUAL_VERSION" ]; then
            echo "::error::Unable to read top appcast version from main at ${FEED_PATH}"
            exit 1
          fi

          if [ "$ACTUAL_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "::error::Appcast on main does not match release tag."
            echo "::error::expected=${EXPECTED_VERSION} actual=${ACTUAL_VERSION} file=${FEED_PATH}"
            echo "::error::If fallback publishing was required, merge branch chore/publish-updates-${TAG_NAME} and rerun this workflow."
            exit 1
          fi

          echo "Verified appcast on main matches release tag: ${ACTUAL_VERSION}"
